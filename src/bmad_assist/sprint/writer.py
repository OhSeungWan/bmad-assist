"""Atomic writer for sprint-status files with comment preservation.

This module implements an atomic writer for sprint-status.yaml files that:
- Uses temp file + os.replace() for crash resilience (same as core/state.py)
- Preserves YAML inline comments when ruamel.yaml is available
- Falls back to PyYAML when ruamel unavailable (comments lost, logs WARNING)
- Maintains entry ordering from SprintStatus.entries dict

Public API:
    - has_ruamel: Check if ruamel.yaml is available for comment preservation
    - write_sprint_status: Main entry point for atomic sprint-status writes
"""

from __future__ import annotations

import logging
import os
from datetime import UTC, datetime
from pathlib import Path
from typing import TYPE_CHECKING, Any

import yaml

from bmad_assist.core.exceptions import StateError
from bmad_assist.sprint.models import SprintStatus

if TYPE_CHECKING:
    from ruamel.yaml.comments import CommentedMap

logger = logging.getLogger(__name__)

__all__ = [
    "has_ruamel",
    "write_sprint_status",
]

# Suffix for temporary files during atomic write (matches core/state.py)
TEMP_FILE_SUFFIX = ".tmp"

# Header comment for generated files
HEADER_TEMPLATE = """# Generated by bmad-assist on {timestamp}
# Sprint Status File - {project}
#
"""

# =============================================================================
# ruamel.yaml Detection (Task 3)
# =============================================================================

# Cache ruamel.yaml availability at module load time
_RUAMEL_AVAILABLE: bool = False
_RUAMEL_CHECKED: bool = False


def _check_ruamel() -> bool:
    """Check if ruamel.yaml is available (internal, caches result)."""
    global _RUAMEL_AVAILABLE, _RUAMEL_CHECKED
    if _RUAMEL_CHECKED:
        return _RUAMEL_AVAILABLE
    try:
        from ruamel.yaml import YAML  # noqa: F401
        from ruamel.yaml.comments import CommentedMap  # noqa: F401

        _RUAMEL_AVAILABLE = True
        logger.debug("ruamel.yaml available for comment preservation")
    except ImportError:
        _RUAMEL_AVAILABLE = False
        logger.debug("ruamel.yaml not available, will use PyYAML fallback")
    _RUAMEL_CHECKED = True
    return _RUAMEL_AVAILABLE


def has_ruamel() -> bool:
    """Check if ruamel.yaml is available for comment preservation.

    Returns:
        True if ruamel.yaml is installed and importable.

    Example:
        >>> if has_ruamel():
        ...     print("Comments will be preserved")
        ... else:
        ...     print("Comments will be lost on write")

    """
    return _check_ruamel()


# =============================================================================
# Comment Loading (Task 4)
# =============================================================================


def _load_with_comments(path: Path) -> tuple[dict[str, Any] | None, dict[str, str]]:
    """Load YAML file preserving comments using ruamel.yaml.

    When ruamel.yaml is available, loads the file in round-trip mode to
    preserve all comments. Extracts inline comments for entries in
    development_status section.

    Args:
        path: Path to YAML file to load.

    Returns:
        Tuple of (loaded_data, comments_dict).
        - loaded_data: CommentedMap if ruamel available, None otherwise
        - comments_dict: Dict mapping entry keys to their inline comments

    Note:
        If ruamel.yaml is unavailable or file doesn't exist, returns (None, {}).

    """
    comments: dict[str, str] = {}

    if not has_ruamel():
        return None, comments

    if not path.exists():
        return None, comments

    try:
        from ruamel.yaml import YAML
        from ruamel.yaml.comments import CommentedMap

        yaml_rt = YAML(typ="rt")
        yaml_rt.preserve_quotes = True

        with open(path, encoding="utf-8") as f:
            data = yaml_rt.load(f)

        if data is None or not isinstance(data, CommentedMap):
            return None, comments

        # Extract inline comments from development_status entries
        dev_status = data.get("development_status")
        if dev_status is not None and isinstance(dev_status, CommentedMap):
            # ruamel stores comments in .ca (Comment Attribute) structure
            # ca.items[key] contains tuples: (pre-comment, inline-comment, ...)
            if hasattr(dev_status, "ca") and hasattr(dev_status.ca, "items"):
                for key in dev_status:
                    comment_token = dev_status.ca.items.get(key)
                    if comment_token is not None:
                        # Structure: [pre_comment, inline_comment, post_comment, ...]
                        # inline_comment is at index 2 (after key and value positions)
                        inline = comment_token[2] if len(comment_token) > 2 else None
                        if inline is not None:
                            # CommentToken has .value attribute with the actual comment
                            comment_text = getattr(inline, "value", None)
                            if comment_text:
                                # Strip leading # and whitespace
                                comment_str = str(comment_text).lstrip("# \t").rstrip()
                                if comment_str:
                                    comments[str(key)] = comment_str

        return data, comments

    except Exception as e:
        # Any error in ruamel parsing - fall back gracefully
        logger.warning("Failed to load with ruamel.yaml: %s", e)
        return None, comments


# =============================================================================
# Output Data Building (Task 5)
# =============================================================================


def _build_output_data(
    status: SprintStatus,
    original_comments: dict[str, str],
) -> dict[str, Any]:
    """Build output data structure from SprintStatus model.

    Constructs the YAML-serializable dict structure preserving entry ordering
    from the SprintStatus.entries dict.

    Args:
        status: SprintStatus model to serialize.
        original_comments: Dict of entry keys to inline comments (for logging).

    Returns:
        Dict ready for YAML serialization.

    """
    # Build metadata section
    data: dict[str, Any] = {
        "generated": status.metadata.generated.isoformat(),
    }

    # Add optional metadata fields if present
    if status.metadata.project:
        data["project"] = status.metadata.project
    if status.metadata.project_key:
        data["project_key"] = status.metadata.project_key
    if status.metadata.tracking_system:
        data["tracking_system"] = status.metadata.tracking_system
    if status.metadata.story_location:
        data["story_location"] = status.metadata.story_location

    # Build development_status section preserving entry order
    dev_status: dict[str, str] = {}
    for key, entry in status.entries.items():
        dev_status[key] = entry.status

    data["development_status"] = dev_status

    # Log comment preservation stats if we had original comments
    if original_comments:
        preserved = sum(1 for k in dev_status if k in original_comments)
        lost = len(original_comments) - preserved
        if lost > 0:
            logger.debug(
                "Comment preservation: %d preserved, %d lost (entries removed)",
                preserved,
                lost,
            )

    return data


# =============================================================================
# ruamel.yaml Writer (Task 6)
# =============================================================================


def _write_with_ruamel(
    data: dict[str, Any],
    original_data: CommentedMap | None,
    comments: dict[str, str],
    path: Path,
    project: str | None,
) -> None:
    """Write sprint-status using ruamel.yaml with comment preservation.

    Uses ruamel.yaml round-trip mode to preserve comments. When original_data
    is available, updates it in-place to preserve all comment associations.

    Note: The ruamel.yaml comment API is internal and may change between versions.
    This implementation uses the simplest approach: update values in-place in
    the original CommentedMap to preserve associated comments automatically.
    When creating new structures, comments are not manually re-attached to avoid
    relying on internal API that may change.

    Args:
        data: New data to write.
        original_data: Original CommentedMap if available (for in-place updates).
        comments: Dict of entry keys to inline comments (unused when original_data is None).
        path: Target file path.
        project: Project name for header comment.

    Raises:
        StateError: If write operation fails.

    """
    from ruamel.yaml import YAML
    from ruamel.yaml.comments import CommentedMap

    temp_path = path.with_suffix(path.suffix + TEMP_FILE_SUFFIX)

    try:
        yaml_rt = YAML(typ="rt")
        yaml_rt.preserve_quotes = True
        yaml_rt.default_flow_style = False

        # Decide whether to update in-place or build new structure
        if original_data is not None:
            output_data = original_data

            # Update metadata fields in-place
            output_data["generated"] = data["generated"]
            for meta_key in ["project", "project_key", "tracking_system", "story_location"]:
                if meta_key in data:
                    output_data[meta_key] = data[meta_key]
                elif meta_key in output_data:
                    del output_data[meta_key]

            # Get or create development_status
            if "development_status" not in output_data:
                output_data["development_status"] = CommentedMap()

            dev_status = output_data["development_status"]

            # Get current keys and new keys
            old_keys = set(dev_status.keys())
            new_data_dev = data.get("development_status", {})
            new_keys = set(new_data_dev.keys())

            # Remove entries not in new data
            for key in old_keys - new_keys:
                del dev_status[key]

            # Update/add entries from new data (in-place preserves comments)
            for key, value in new_data_dev.items():
                dev_status[key] = value

            # Re-order keys to match model's entry order (AC3)
            # move_to_end(last=True) moves each key to end in sequence,
            # resulting in the same order as new_data_dev
            for key in new_data_dev.keys():
                if key in dev_status:
                    dev_status.move_to_end(key, last=True)

        else:
            # Build new CommentedMap structure (comments won't be preserved
            # since we don't have original data to update in-place)
            output_data = CommentedMap()

            # Add metadata
            output_data["generated"] = data["generated"]
            for meta_key in ["project", "project_key", "tracking_system", "story_location"]:
                if meta_key in data:
                    output_data[meta_key] = data[meta_key]

            # Add development_status
            dev_status = CommentedMap()
            for key, value in data.get("development_status", {}).items():
                dev_status[key] = value
            output_data["development_status"] = dev_status

            # Note: We don't manually re-attach comments here to avoid relying
            # on internal ruamel.yaml API that changes between versions.
            # Comment preservation only works when updating existing files.

        # Add header comment
        timestamp = datetime.now(UTC).replace(tzinfo=None).isoformat(timespec="seconds")
        header = HEADER_TEMPLATE.format(timestamp=timestamp, project=project or "unknown")
        output_data.yaml_set_start_comment(header)

        # Create parent directories if missing
        path.parent.mkdir(parents=True, exist_ok=True)

        # Write to temp file
        with open(temp_path, "w", encoding="utf-8") as f:
            yaml_rt.dump(output_data, f)

        # Atomic replace
        os.replace(temp_path, path)

    except OSError as e:
        # Attempt cleanup but don't fail if we can't check/delete
        try:
            if temp_path.exists():
                temp_path.unlink()
        except OSError:
            pass  # Best-effort cleanup
        raise StateError(f"Failed to write sprint-status to {path}: {e}") from e


# =============================================================================
# PyYAML Fallback Writer (Task 7)
# =============================================================================


def _write_with_pyyaml(
    data: dict[str, Any],
    path: Path,
    project: str | None,
) -> None:
    """Write sprint-status using PyYAML (no comment preservation).

    Fallback writer when ruamel.yaml is unavailable. Comments from the
    original file will be lost.

    Args:
        data: Data to write.
        path: Target file path.
        project: Project name for header comment.

    Raises:
        StateError: If write operation fails.

    """
    temp_path = path.with_suffix(path.suffix + TEMP_FILE_SUFFIX)

    try:
        # Create parent directories if missing
        path.parent.mkdir(parents=True, exist_ok=True)

        # Build content with header
        timestamp = datetime.now(UTC).replace(tzinfo=None).isoformat(timespec="seconds")
        header = HEADER_TEMPLATE.format(timestamp=timestamp, project=project or "unknown")

        yaml_content = yaml.dump(
            data,
            default_flow_style=False,
            sort_keys=False,
            allow_unicode=True,
        )

        # Write to temp file
        with open(temp_path, "w", encoding="utf-8") as f:
            f.write(header)
            f.write(yaml_content)

        # Atomic replace
        os.replace(temp_path, path)

    except OSError as e:
        # Attempt cleanup but don't fail if we can't check/delete
        try:
            if temp_path.exists():
                temp_path.unlink()
        except OSError:
            pass  # Best-effort cleanup
        raise StateError(f"Failed to write sprint-status to {path}: {e}") from e


# =============================================================================
# Main Write Function (Task 8)
# =============================================================================


def write_sprint_status(
    status: SprintStatus,
    path: Path | str,
    preserve_comments: bool = True,
) -> None:
    """Write sprint-status to YAML with optional comment preservation.

    Uses ruamel.yaml for round-trip comment preservation when available.
    Falls back to PyYAML (comments lost) when ruamel unavailable.

    The write is atomic: uses temp file + os.replace() to ensure crash
    resilience. Previous valid state is never corrupted by partial writes.

    Args:
        status: SprintStatus model to write.
        path: Target file path (str or Path). Tilde (~) is expanded.
        preserve_comments: If True and ruamel available, preserve inline
            comments from original file. Default True.

    Raises:
        StateError: If write operation fails.

    Example:
        >>> from bmad_assist.sprint.writer import write_sprint_status
        >>> from bmad_assist.sprint.models import SprintStatus
        >>> status = SprintStatus.empty("my-project")
        >>> write_sprint_status(status, Path("sprint-status.yaml"))

    Note:
        - If file doesn't exist, creates new file without comments
        - Entry ordering is preserved from status.entries dict
        - Comments for removed entries are silently dropped

    """
    path = Path(path).expanduser()
    project = status.metadata.project

    # Load original comments if requested and ruamel available
    original_data: CommentedMap | None = None
    comments: dict[str, str] = {}

    if preserve_comments and has_ruamel() and path.exists():
        original_data_result, comments = _load_with_comments(path)
        if original_data_result is not None:
            # Cast for type checking - we verified ruamel is available
            from ruamel.yaml.comments import CommentedMap

            if isinstance(original_data_result, CommentedMap):
                original_data = original_data_result

    # Build output data structure
    data = _build_output_data(status, comments)

    # Choose backend
    if preserve_comments and has_ruamel():
        logger.debug("Writing sprint-status with ruamel.yaml (comment preservation)")
        _write_with_ruamel(data, original_data, comments, path, project)
    else:
        if preserve_comments and not has_ruamel():
            logger.warning("ruamel.yaml not available, writing with PyYAML (comments will be lost)")
        _write_with_pyyaml(data, path, project)
