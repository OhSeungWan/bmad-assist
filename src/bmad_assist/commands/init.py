"""Init command for bmad-assist CLI.

Initializes a project for bmad-assist usage.
"""

from pathlib import Path

import typer

from bmad_assist.cli_utils import (
    EXIT_ERROR,
    _error,
    _success,
    console,
)


def _validate_bundled_workflows(console: "rich.console.Console") -> None:
    """Validate bundled workflows are properly installed."""
    from bmad_assist.workflows import list_bundled_workflows

    expected_custom = {
        "validate-story",
        "validate-story-synthesis",
        "code-review",
        "code-review-synthesis",
        "qa-plan-generate",
        "qa-plan-execute",
    }
    expected_standard = {
        "create-story",
        "dev-story",
        "retrospective",
        "testarch-atdd",
        "testarch-trace",
        "testarch-test-review",
    }
    expected = expected_custom | expected_standard

    bundled = set(list_bundled_workflows())
    missing = expected - bundled

    if missing:
        console.print(f"  [red]Missing bundled workflows:[/red] {', '.join(sorted(missing))}")
        console.print("  [yellow]Fix: reinstall bmad-assist with `pip install -e .`[/yellow]")
    else:
        console.print(f"  [green]All {len(bundled)} bundled workflows available[/green]")


# Default BMAD config template for bundled workflows
_DEFAULT_BMAD_CONFIG = """\
# BMM Module Configuration
# Generated by bmad-assist init
# This minimal config enables bundled workflows without full BMAD installation

project_name: {project_name}
user_name: User
communication_language: English
document_output_language: English
user_skill_level: intermediate

# Path configuration
output_folder: "{{project-root}}/_bmad-output"
planning_artifacts: "{{project-root}}/_bmad-output/planning-artifacts"
implementation_artifacts: "{{project-root}}/_bmad-output/implementation-artifacts"
project_knowledge: "{{project-root}}/docs"
"""


def _setup_bmad_config(
    project_path: Path,
    console: "rich.console.Console",
    dry_run: bool = False,
) -> bool:
    """Create default BMAD config if it doesn't exist.

    This enables bundled workflows to work without full BMAD installation.

    Args:
        project_path: Project root directory.
        console: Rich console for output.
        dry_run: If True, don't actually create files.

    Returns:
        True if config was created, False if already exists.

    """
    config_dir = project_path / "_bmad" / "bmm"
    config_file = config_dir / "config.yaml"

    if config_file.exists():
        console.print(f"  [dim]BMAD config:[/dim] Already exists at {config_file.relative_to(project_path)}")
        return False

    # Generate config content
    project_name = project_path.name
    config_content = _DEFAULT_BMAD_CONFIG.format(project_name=project_name)

    if dry_run:
        console.print(f"  [dim]Would create:[/dim] {config_file.relative_to(project_path)}")
        return True

    # Create directory and file
    config_dir.mkdir(parents=True, exist_ok=True)
    config_file.write_text(config_content, encoding="utf-8")
    console.print(f"  [green]Created:[/green] {config_file.relative_to(project_path)}")
    return True


def init_command(
    project: str = typer.Option(
        ".",
        "--project",
        "-p",
        help="Path to project directory to initialize",
    ),
    dry_run: bool = typer.Option(
        False,
        "--dry-run",
        "-n",
        help="Show what would be done without making changes",
    ),
    force: bool = typer.Option(
        False,
        "--force",
        "-f",
        help="Overwrite existing configuration if present",
    ),
) -> None:
    """Initialize a project for bmad-assist.

    Sets up the project with required configuration:
    - Creates .bmad-assist/ directory for state and cache
    - Adds required patterns to .gitignore to prevent committing artifacts

    This command is idempotent - safe to run multiple times.

    Examples:
        bmad-assist init                    # Initialize current directory
        bmad-assist init -p ./my-project    # Initialize specific project
        bmad-assist init --dry-run          # Preview changes without applying

    """
    from bmad_assist.git import check_gitignore, setup_gitignore

    project_path = Path(project).resolve()

    if not project_path.exists():
        _error(f"Project directory does not exist: {project_path}")
        raise typer.Exit(code=EXIT_ERROR)

    if not project_path.is_dir():
        _error(f"Path is not a directory: {project_path}")
        raise typer.Exit(code=EXIT_ERROR)

    console.print(f"[bold]Initializing bmad-assist in:[/bold] {project_path}")
    console.print()

    changes_made = False

    # 1. Create .bmad-assist directory
    bmad_dir = project_path / ".bmad-assist"
    cache_dir = bmad_dir / "cache"

    if not bmad_dir.exists():
        if dry_run:
            console.print(f"  [dim]Would create:[/dim] {bmad_dir}/")
            changes_made = True
        else:
            bmad_dir.mkdir(parents=True, exist_ok=True)
            cache_dir.mkdir(exist_ok=True)
            console.print(f"  [green]Created:[/green] {bmad_dir}/")
            changes_made = True
    else:
        console.print(f"  [dim]Already exists:[/dim] {bmad_dir}/")
        # Ensure cache subdir exists
        if not cache_dir.exists() and not dry_run:
            cache_dir.mkdir(exist_ok=True)

    # 2. Setup .gitignore
    all_present, missing = check_gitignore(project_path)

    if all_present:
        console.print("  [dim].gitignore:[/dim] All bmad-assist patterns present")
    else:
        changed, message = setup_gitignore(project_path, dry_run=dry_run)
        if changed:
            if dry_run:
                console.print(f"  [dim]Would update .gitignore:[/dim] {message}")
            else:
                console.print(f"  [green].gitignore:[/green] {message}")
            changes_made = True
        else:
            console.print(f"  [yellow].gitignore:[/yellow] {message}")

    # 3. Create default BMAD config if missing (enables bundled workflows)
    if _setup_bmad_config(project_path, console, dry_run=dry_run):
        changes_made = True

    # 4. Verify bundled workflows
    console.print()
    console.print("[bold]Workflow validation:[/bold]")
    _validate_bundled_workflows(console)

    # Summary
    console.print()
    if dry_run:
        if changes_made:
            console.print(
                "[yellow]Dry run - no changes made. Run without --dry-run to apply.[/yellow]"
            )
        else:
            console.print("[green]Project already initialized - no changes needed.[/green]")
    else:
        if changes_made:
            _success("Project initialized successfully")
        else:
            console.print("[green]Project already initialized - no changes needed.[/green]")
